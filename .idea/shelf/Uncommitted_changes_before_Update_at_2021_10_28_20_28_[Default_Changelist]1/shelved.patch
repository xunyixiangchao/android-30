Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .gitignore	(date 1634221166007)
+++ .gitignore	(date 1634221166007)
@@ -0,0 +1,15 @@
+*.iml
+.gradle
+/local.properties
+/.idea/caches
+/.idea/libraries
+/.idea/modules.xml
+/.idea/workspace.xml
+/.idea/navEditor.xml
+/.idea/assetWizardSettings.xml
+.DS_Store
+/build
+/captures
+.externalNativeBuild
+.cxx
+local.properties
Index: .idea/jarRepositories.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/jarRepositories.xml	(date 1635424089179)
+++ .idea/jarRepositories.xml	(date 1635424089179)
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="RemoteRepositoriesConfiguration">
+    <remote-repository>
+      <option name="id" value="central" />
+      <option name="name" value="Maven Central repository" />
+      <option name="url" value="https://repo1.maven.org/maven2" />
+    </remote-repository>
+    <remote-repository>
+      <option name="id" value="jboss.community" />
+      <option name="name" value="JBoss Community repository" />
+      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />
+    </remote-repository>
+    <remote-repository>
+      <option name="id" value="BintrayJCenter" />
+      <option name="name" value="BintrayJCenter" />
+      <option name="url" value="https://jcenter.bintray.com/" />
+    </remote-repository>
+    <remote-repository>
+      <option name="id" value="Google" />
+      <option name="name" value="Google" />
+      <option name="url" value="https://dl.google.com/dl/android/maven2/" />
+    </remote-repository>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_2021_10_28_20_28_[Default_Changelist]/shelved.patch
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_2021_10_28_20_28_[Default_Changelist]/shelved.patch	(date 1635424098193)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_2021_10_28_20_28_[Default_Changelist]/shelved.patch	(date 1635424098193)
@@ -0,0 +1,120 @@
+Index: app/src/main/java/com/lis/source_30/MainActivity.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
+<+>package com.lis.source_30;\n\nimport androidx.appcompat.app.AppCmpatActivity;\n\nimport android.os.Bundle;\n\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n}
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+--- app/src/main/java/com/lis/source_30/MainActivity.java	(revision cb0a8564dd664fda5d4b0c9e399c54dabccbea85)
++++ app/src/main/java/com/lis/source_30/MainActivity.java	(date 1634651600054)
+@@ -10,5 +10,6 @@
+     protected void onCreate(Bundle savedInstanceState) {
+         super.onCreate(savedInstanceState);
+         setContentView(R.layout.activity_main);
++
+     }
+ }
+\ No newline at end of file
+Index: .idea/misc.xml
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+--- .idea/misc.xml	(date 1635424076291)
++++ .idea/misc.xml	(date 1635424076291)
+@@ -0,0 +1,6 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<project version="4">
++  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
++    <output url="file://$PROJECT_DIR$/build/classes" />
++  </component>
++</project>
+\ No newline at end of file
+Index: .idea/.gitignore
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+--- .idea/.gitignore	(date 1634221195919)
++++ .idea/.gitignore	(date 1634221195919)
+@@ -0,0 +1,3 @@
++# Default ignored files
++/shelf/
++/workspace.xml
+Index: com/android/internal/widget/ViewPager.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
+<+>/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.internal.widget;\n\nimport android.annotation.DrawableRes;\nimport android.annotation.NonNull;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.database.DataSetObserver;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.graphics.drawable.Drawable;\nimport android.os.Bundle;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.view.AbsSavedState;\nimport android.view.FocusFinder;\nimport android.view.Gravity;\nimport android.view.KeyEvent;\nimport android.view.MotionEvent;\nimport android.view.SoundEffectConstants;\nimport android.view.VelocityTracker;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.view.ViewParent;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityNodeInfo;\nimport android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction;\nimport android.view.animation.Interpolator;\nimport android.view.inspector.InspectableProperty;\nimport android.widget.EdgeEffect;\nimport android.widget.Scroller;\n\nimport com.android.internal.R;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n/**\n * Framework copy of the support-v4 ViewPager class.\n */\npublic class ViewPager extends ViewGroup {\n    private static final String TAG = \"ViewPager\";\n    private static final boolean DEBUG = false;\n\n    private static final int MAX_SCROLL_X = 2 << 23;\n    private static final boolean USE_CACHE = false;\n\n    private static final int DEFAULT_OFFSCREEN_PAGES = 1;\n    private static final int MAX_SETTLE_DURATION = 600; // ms\n    private static final int MIN_DISTANCE_FOR_FLING = 25; // dips\n\n    private static final int DEFAULT_GUTTER_SIZE = 16; // dips\n\n    private static final int MIN_FLING_VELOCITY = 400; // dips\n\n    private static final int[] LAYOUT_ATTRS = new int[] {\n        com.android.internal.R.attr.layout_gravity\n    };\n\n    /**\n     * Used to track what the expected number of items in the adapter should be.\n     * If the app changes this when we don't expect it, we'll throw a big obnoxious exception.\n     */\n    private int mExpectedAdapterCount;\n\n    static class ItemInfo {\n        Object object;\n        boolean scrolling;\n        float widthFactor;\n\n        /** Logical position of the item within the pager adapter. */\n        int position;\n\n        /** Offset between the starting edges of the item and its container. */\n        float offset;\n    }\n\n    private static final Comparator<ItemInfo> COMPARATOR = new Comparator<ItemInfo>(){\n        @Override\n        public int compare(ItemInfo lhs, ItemInfo rhs) {\n            return lhs.position - rhs.position;\n        }\n    };\n\n    private static final Interpolator sInterpolator = new Interpolator() {\n        public float getInterpolation(float t) {\n            t -= 1.0f;\n            return t * t * t * t * t + 1.0f;\n        }\n    };\n\n    private final ArrayList<ItemInfo> mItems = new ArrayList<ItemInfo>();\n    private final ItemInfo mTempItem = new ItemInfo();\n\n    private final Rect mTempRect = new Rect();\n\n    private PagerAdapter mAdapter;\n    private int mCurItem;   // Index of currently displayed page.\n    private int mRestoredCurItem = -1;\n    private Parcelable mRestoredAdapterState = null;\n    private ClassLoader mRestoredClassLoader = null;\n    private final Scroller mScroller;\n    private PagerObserver mObserver;\n\n    private int mPageMargin;\n    private Drawable mMarginDrawable;\n    private int mTopPageBounds;\n    private int mBottomPageBounds;\n\n    /**\n     * The increment used to move in the \"left\" direction. Dependent on layout\n     * direction.\n     */\n    private int mLeftIncr = -1;\n\n    // Offsets of the first and last items, if known.\n    // Set during population, used to determine if we are at the beginning\n    // or end of the pager data set during touch scrolling.\n    private float mFirstOffset = -Float.MAX_VALUE;\n    private float mLastOffset = Float.MAX_VALUE;\n\n    private int mChildWidthMeasureSpec;\n    private int mChildHeightMeasureSpec;\n    private boolean mInLayout;\n\n    private boolean mScrollingCacheEnabled;\n\n    private boolean mPopulatePending;\n    private int mOffscreenPageLimit = DEFAULT_OFFSCREEN_PAGES;\n\n    private boolean mIsBeingDragged;\n    private boolean mIsUnableToDrag;\n    private final int mDefaultGutterSize;\n    private int mGutterSize;\n    private final int mTouchSlop;\n    /**\n     * Position of the last motion event.\n     */\n    private float mLastMotionX;\n    private float mLastMotionY;\n    private float mInitialMotionX;\n    private float mInitialMotionY;\n    /**\n     * ID of the active pointer. This is used to retain consistency during\n     * drags/flings if multiple pointers are used.\n     */\n    private int mActivePointerId = INVALID_POINTER;\n    /**\n     * Sentinel value for no current active pointer.\n     * Used by {@link #mActivePointerId}.\n     */\n    private static final int INVALID_POINTER = -1;\n\n    /**\n     * Determines speed during touch scrolling\n     */\n    private VelocityTracker mVelocityTracker;\n    private final int mMinimumVelocity;\n    private final int mMaximumVelocity;\n    private final int mFlingDistance;\n    private final int mCloseEnough;\n\n    // If the pager is at least this close to its final position, complete the scroll\n    // on touch down and let the user interact with the content inside instead of\n    // \"catching\" the flinging pager.\n    private static final int CLOSE_ENOUGH = 2; // dp\n\n    private final EdgeEffect mLeftEdge;\n    private final EdgeEffect mRightEdge;\n\n    private boolean mFirstLayout = true;\n    private boolean mCalledSuper;\n    private int mDecorChildCount;\n\n    private OnPageChangeListener mOnPageChangeListener;\n    private OnPageChangeListener mInternalPageChangeListener;\n    private OnAdapterChangeListener mAdapterChangeListener;\n    private PageTransformer mPageTransformer;\n\n    private static final int DRAW_ORDER_DEFAULT = 0;\n    private static final int DRAW_ORDER_FORWARD = 1;\n    private static final int DRAW_ORDER_REVERSE = 2;\n    private int mDrawingOrder;\n    private ArrayList<View> mDrawingOrderedChildren;\n    private static final ViewPositionComparator sPositionComparator = new ViewPositionComparator();\n\n    /**\n     * Indicates that the pager is in an idle, settled state. The current page\n     * is fully in view and no animation is in progress.\n     */\n    public static final int SCROLL_STATE_IDLE = 0;\n\n    /**\n     * Indicates that the pager is currently being dragged by the user.\n     */\n    public static final int SCROLL_STATE_DRAGGING = 1;\n\n    /**\n     * Indicates that the pager is in the process of settling to a final position.\n     */\n    public static final int SCROLL_STATE_SETTLING = 2;\n\n    private final Runnable mEndScrollRunnable = new Runnable() {\n        public void run() {\n            setScrollState(SCROLL_STATE_IDLE);\n            populate();\n        }\n    };\n\n    private int mScrollState = SCROLL_STATE_IDLE;\n\n    /**\n     * Callback interface for responding to changing state of the selected page.\n     */\n    public interface OnPageChangeListener {\n\n        /**\n         * This method will be invoked when the current page is scrolled, either as part\n         * of a programmatically initiated smooth scroll or a user initiated touch scroll.\n         *\n         * @param position Position index of the first page currently being displayed.\n         *                 Page position+1 will be visible if positionOffset is nonzero.\n         * @param positionOffset Value from [0, 1) indicating the offset from the page at position.\n         * @param positionOffsetPixels Value in pixels indicating the offset from position.\n         */\n        @UnsupportedAppUsage\n        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels);\n\n        /**\n         * This method will be invoked when a new page becomes selected. Animation is not\n         * necessarily complete.\n         *\n         * @param position Position index of the new selected page.\n         */\n        @UnsupportedAppUsage\n        public void onPageSelected(int position);\n\n        /**\n         * Called when the scroll state changes. Useful for discovering when the user\n         * begins dragging, when the pager is automatically settling to the current page,\n         * or when it is fully stopped/idle.\n         *\n         * @param state The new scroll state.\n         * @see com.android.internal.widget.ViewPager#SCROLL_STATE_IDLE\n         * @see com.android.internal.widget.ViewPager#SCROLL_STATE_DRAGGING\n         * @see com.android.internal.widget.ViewPager#SCROLL_STATE_SETTLING\n         */\n        @UnsupportedAppUsage\n        public void onPageScrollStateChanged(int state);\n    }\n\n    /**\n     * Simple implementation of the {@link OnPageChangeListener} interface with stub\n     * implementations of each method. Extend this if you do not intend to override\n     * every method of {@link OnPageChangeListener}.\n     */\n    public static class SimpleOnPageChangeListener implements OnPageChangeListener {\n        @Override\n        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n            // This space for rent\n        }\n\n        @Override\n        public void onPageSelected(int position) {\n            // This space for rent\n        }\n\n        @Override\n        public void onPageScrollStateChanged(int state) {\n            // This space for rent\n        }\n    }\n\n    /**\n     * A PageTransformer is invoked whenever a visible/attached page is scrolled.\n     * This offers an opportunity for the application to apply a custom transformation\n     * to the page views using animation properties.\n     *\n     * <p>As property animation is only supported as of Android 3.0 and forward,\n     * setting a PageTransformer on a ViewPager on earlier platform versions will\n     * be ignored.</p>\n     */\n    public interface PageTransformer {\n        /**\n         * Apply a property transformation to the given page.\n         *\n         * @param page Apply the transformation to this page\n         * @param position Position of page relative to the current front-and-center\n         *                 position of the pager. 0 is front and center. 1 is one full\n         *                 page position to the right, and -1 is one page position to the left.\n         */\n        public void transformPage(View page, float position);\n    }\n\n    /**\n     * Used internally to monitor when adapters are switched.\n     */\n    interface OnAdapterChangeListener {\n        public void onAdapterChanged(PagerAdapter oldAdapter, PagerAdapter newAdapter);\n    }\n\n    /**\n     * Used internally to tag special types of child views that should be added as\n     * pager decorations by default.\n     */\n    interface Decor {}\n\n    public ViewPager(Context context) {\n        this(context, null);\n    }\n\n    public ViewPager(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public ViewPager(Context context, AttributeSet attrs, int defStyleAttr) {\n        this(context, attrs, defStyleAttr, 0);\n    }\n\n    public ViewPager(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n        super(context, attrs, defStyleAttr, defStyleRes);\n\n        setWillNotDraw(false);\n        setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);\n        setFocusable(true);\n\n        mScroller = new Scroller(context, sInterpolator);\n        final ViewConfiguration configuration = ViewConfiguration.get(context);\n        final float density = context.getResources().getDisplayMetrics().density;\n\n        mTouchSlop = configuration.getScaledPagingTouchSlop();\n        mMinimumVelocity = (int) (MIN_FLING_VELOCITY * density);\n        mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();\n        mLeftEdge = new EdgeEffect(context);\n        mRightEdge = new EdgeEffect(context);\n\n        mFlingDistance = (int) (MIN_DISTANCE_FOR_FLING * density);\n        mCloseEnough = (int) (CLOSE_ENOUGH * density);\n        mDefaultGutterSize = (int) (DEFAULT_GUTTER_SIZE * density);\n\n        if (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {\n            setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);\n        }\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        removeCallbacks(mEndScrollRunnable);\n        super.onDetachedFromWindow();\n    }\n\n    private void setScrollState(int newState) {\n        if (mScrollState == newState) {\n            return;\n        }\n\n        mScrollState = newState;\n        if (mPageTransformer != null) {\n            // PageTransformers can do complex things that benefit from hardware layers.\n            enableLayers(newState != SCROLL_STATE_IDLE);\n        }\n        if (mOnPageChangeListener != null) {\n            mOnPageChangeListener.onPageScrollStateChanged(newState);\n        }\n    }\n\n    /**\n     * Set a PagerAdapter that will supply views for this pager as needed.\n     *\n     * @param adapter Adapter to use\n     */\n    public void setAdapter(PagerAdapter adapter) {\n        if (mAdapter != null) {\n            mAdapter.unregisterDataSetObserver(mObserver);\n            mAdapter.startUpdate(this);\n            for (int i = 0; i < mItems.size(); i++) {\n                final ItemInfo ii = mItems.get(i);\n                mAdapter.destroyItem(this, ii.position, ii.object);\n            }\n            mAdapter.finishUpdate(this);\n            mItems.clear();\n            removeNonDecorViews();\n            mCurItem = 0;\n            scrollTo(0, 0);\n        }\n\n        final PagerAdapter oldAdapter = mAdapter;\n        mAdapter = adapter;\n        mExpectedAdapterCount = 0;\n\n        if (mAdapter != null) {\n            if (mObserver == null) {\n                mObserver = new PagerObserver();\n            }\n            mAdapter.registerDataSetObserver(mObserver);\n            mPopulatePending = false;\n            final boolean wasFirstLayout = mFirstLayout;\n            mFirstLayout = true;\n            mExpectedAdapterCount = mAdapter.getCount();\n            if (mRestoredCurItem >= 0) {\n                mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);\n                setCurrentItemInternal(mRestoredCurItem, false, true);\n                mRestoredCurItem = -1;\n                mRestoredAdapterState = null;\n                mRestoredClassLoader = null;\n            } else if (!wasFirstLayout) {\n                populate();\n            } else {\n                requestLayout();\n            }\n        }\n\n        if (mAdapterChangeListener != null && oldAdapter != adapter) {\n            mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);\n        }\n    }\n\n    private void removeNonDecorViews() {\n        for (int i = 0; i < getChildCount(); i++) {\n            final View child = getChildAt(i);\n            final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n            if (!lp.isDecor) {\n                removeViewAt(i);\n                i--;\n            }\n        }\n    }\n\n    /**\n     * Retrieve the current adapter supplying pages.\n     *\n     * @return The currently registered PagerAdapter\n     */\n    public PagerAdapter getAdapter() {\n        return mAdapter;\n    }\n\n    void setOnAdapterChangeListener(OnAdapterChangeListener listener) {\n        mAdapterChangeListener = listener;\n    }\n\n    private int getPaddedWidth() {\n        return getMeasuredWidth() - getPaddingLeft() - getPaddingRight();\n    }\n\n    /**\n     * Set the currently selected page. If the ViewPager has already been through its first\n     * layout with its current adapter there will be a smooth animated transition between\n     * the current item and the specified item.\n     *\n     * @param item Item index to select\n     */\n    public void setCurrentItem(int item) {\n        mPopulatePending = false;\n        setCurrentItemInternal(item, !mFirstLayout, false);\n    }\n\n    /**\n     * Set the currently selected page.\n     *\n     * @param item Item index to select\n     * @param smoothScroll True to smoothly scroll to the new item, false to transition immediately\n     */\n    public void setCurrentItem(int item, boolean smoothScroll) {\n        mPopulatePending = false;\n        setCurrentItemInternal(item, smoothScroll, false);\n    }\n\n    @UnsupportedAppUsage\n    public int getCurrentItem() {\n        return mCurItem;\n    }\n\n    boolean setCurrentItemInternal(int item, boolean smoothScroll, boolean always) {\n        return setCurrentItemInternal(item, smoothScroll, always, 0);\n    }\n\n    boolean setCurrentItemInternal(int item, boolean smoothScroll, boolean always, int velocity) {\n        if (mAdapter == null || mAdapter.getCount() <= 0) {\n            setScrollingCacheEnabled(false);\n            return false;\n        }\n\n        item = MathUtils.constrain(item, 0, mAdapter.getCount() - 1);\n        if (!always && mCurItem == item && mItems.size() != 0) {\n            setScrollingCacheEnabled(false);\n            return false;\n        }\n\n        final int pageLimit = mOffscreenPageLimit;\n        if (item > (mCurItem + pageLimit) || item < (mCurItem - pageLimit)) {\n            // We are doing a jump by more than one page.  To avoid\n            // glitches, we want to keep all current pages in the view\n            // until the scroll ends.\n            for (int i = 0; i < mItems.size(); i++) {\n                mItems.get(i).scrolling = true;\n            }\n        }\n\n        final boolean dispatchSelected = mCurItem != item;\n        if (mFirstLayout) {\n            // We don't have any idea how big we are yet and shouldn't have any pages either.\n            // Just set things up and let the pending layout handle things.\n            mCurItem = item;\n            if (dispatchSelected && mOnPageChangeListener != null) {\n                mOnPageChangeListener.onPageSelected(item);\n            }\n            if (dispatchSelected && mInternalPageChangeListener != null) {\n                mInternalPageChangeListener.onPageSelected(item);\n            }\n            requestLayout();\n        } else {\n            populate(item);\n            scrollToItem(item, smoothScroll, velocity, dispatchSelected);\n        }\n\n        return true;\n    }\n\n    private void scrollToItem(int position, boolean smoothScroll, int velocity,\n            boolean dispatchSelected) {\n        final int destX = getLeftEdgeForItem(position);\n\n        if (smoothScroll) {\n            smoothScrollTo(destX, 0, velocity);\n\n            if (dispatchSelected && mOnPageChangeListener != null) {\n                mOnPageChangeListener.onPageSelected(position);\n            }\n            if (dispatchSelected && mInternalPageChangeListener != null) {\n                mInternalPageChangeListener.onPageSelected(position);\n            }\n        } else {\n            if (dispatchSelected && mOnPageChangeListener != null) {\n                mOnPageChangeListener.onPageSelected(position);\n            }\n            if (dispatchSelected && mInternalPageChangeListener != null) {\n                mInternalPageChangeListener.onPageSelected(position);\n            }\n\n            completeScroll(false);\n            scrollTo(destX, 0);\n            pageScrolled(destX);\n        }\n    }\n\n    private int getLeftEdgeForItem(int position) {\n        final ItemInfo info = infoForPosition(position);\n        if (info == null) {\n            return 0;\n        }\n\n        final int width = getPaddedWidth();\n        final int scaledOffset = (int) (width * MathUtils.constrain(\n                info.offset, mFirstOffset, mLastOffset));\n\n        if (isLayoutRtl()) {\n            final int itemWidth = (int) (width * info.widthFactor + 0.5f);\n            return MAX_SCROLL_X - itemWidth - scaledOffset;\n        } else {\n            return scaledOffset;\n        }\n    }\n\n    /**\n     * Set a listener that will be invoked whenever the page changes or is incrementally\n     * scrolled. See {@link OnPageChangeListener}.\n     *\n     * @param listener Listener to set\n     */\n    public void setOnPageChangeListener(OnPageChangeListener listener) {\n        mOnPageChangeListener = listener;\n    }\n\n    /**\n     * Set a {@link PageTransformer} that will be called for each attached page whenever\n     * the scroll position is changed. This allows the application to apply custom property\n     * transformations to each page, overriding the default sliding look and feel.\n     *\n     * <p><em>Note:</em> Prior to Android 3.0 the property animation APIs did not exist.\n     * As a result, setting a PageTransformer prior to Android 3.0 (API 11) will have no effect.</p>\n     *\n     * @param reverseDrawingOrder true if the supplied PageTransformer requires page views\n     *                            to be drawn from last to first instead of first to last.\n     * @param transformer PageTransformer that will modify each page's animation properties\n     */\n    public void setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer) {\n        final boolean hasTransformer = transformer != null;\n        final boolean needsPopulate = hasTransformer != (mPageTransformer != null);\n        mPageTransformer = transformer;\n        setChildrenDrawingOrderEnabled(hasTransformer);\n        if (hasTransformer) {\n            mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD;\n        } else {\n            mDrawingOrder = DRAW_ORDER_DEFAULT;\n        }\n        if (needsPopulate) populate();\n    }\n\n    @Override\n    protected int getChildDrawingOrder(int childCount, int i) {\n        final int index = mDrawingOrder == DRAW_ORDER_REVERSE ? childCount - 1 - i : i;\n        final int result = ((LayoutParams) mDrawingOrderedChildren.get(index).getLayoutParams()).childIndex;\n        return result;\n    }\n\n    /**\n     * Set a separate OnPageChangeListener for internal use by the support library.\n     *\n     * @param listener Listener to set\n     * @return The old listener that was set, if any.\n     */\n    OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener) {\n        OnPageChangeListener oldListener = mInternalPageChangeListener;\n        mInternalPageChangeListener = listener;\n        return oldListener;\n    }\n\n    /**\n     * Returns the number of pages that will be retained to either side of the\n     * current page in the view hierarchy in an idle state. Defaults to 1.\n     *\n     * @return How many pages will be kept offscreen on either side\n     * @see #setOffscreenPageLimit(int)\n     */\n    public int getOffscreenPageLimit() {\n        return mOffscreenPageLimit;\n    }\n\n    /**\n     * Set the number of pages that should be retained to either side of the\n     * current page in the view hierarchy in an idle state. Pages beyond this\n     * limit will be recreated from the adapter when needed.\n     *\n     * <p>This is offered as an optimization. If you know in advance the number\n     * of pages you will need to support or have lazy-loading mechanisms in place\n     * on your pages, tweaking this setting can have benefits in perceived smoothness\n     * of paging animations and interaction. If you have a small number of pages (3-4)\n     * that you can keep active all at once, less time will be spent in layout for\n     * newly created view subtrees as the user pages back and forth.</p>\n     *\n     * <p>You should keep this limit low, especially if your pages have complex layouts.\n     * This setting defaults to 1.</p>\n     *\n     * @param limit How many pages will be kept offscreen in an idle state.\n     */\n    public void setOffscreenPageLimit(int limit) {\n        if (limit < DEFAULT_OFFSCREEN_PAGES) {\n            Log.w(TAG, \"Requested offscreen page limit \" + limit + \" too small; defaulting to \" +\n                    DEFAULT_OFFSCREEN_PAGES);\n            limit = DEFAULT_OFFSCREEN_PAGES;\n        }\n        if (limit != mOffscreenPageLimit) {\n            mOffscreenPageLimit = limit;\n            populate();\n        }\n    }\n\n    /**\n     * Set the margin between pages.\n     *\n     * @param marginPixels Distance between adjacent pages in pixels\n     * @see #getPageMargin()\n     * @see #setPageMarginDrawable(android.graphics.drawable.Drawable)\n     * @see #setPageMarginDrawable(int)\n     */\n    public void setPageMargin(int marginPixels) {\n        final int oldMargin = mPageMargin;\n        mPageMargin = marginPixels;\n\n        final int width = getWidth();\n        recomputeScrollPosition(width, width, marginPixels, oldMargin);\n\n        requestLayout();\n    }\n\n    /**\n     * Return the margin between pages.\n     *\n     * @return The size of the margin in pixels\n     */\n    public int getPageMargin() {\n        return mPageMargin;\n    }\n\n    /**\n     * Set a drawable that will be used to fill the margin between pages.\n     *\n     * @param d Drawable to display between pages\n     */\n    public void setPageMarginDrawable(Drawable d) {\n        mMarginDrawable = d;\n        if (d != null) refreshDrawableState();\n        setWillNotDraw(d == null);\n        invalidate();\n    }\n\n    /**\n     * Set a drawable that will be used to fill the margin between pages.\n     *\n     * @param resId Resource ID of a drawable to display between pages\n     */\n    public void setPageMarginDrawable(@DrawableRes int resId) {\n        setPageMarginDrawable(getContext().getDrawable(resId));\n    }\n\n    @Override\n    protected boolean verifyDrawable(@NonNull Drawable who) {\n        return super.verifyDrawable(who) || who == mMarginDrawable;\n    }\n\n    @Override\n    protected void drawableStateChanged() {\n        super.drawableStateChanged();\n        final Drawable marginDrawable = mMarginDrawable;\n        if (marginDrawable != null && marginDrawable.isStateful()\n                && marginDrawable.setState(getDrawableState())) {\n            invalidateDrawable(marginDrawable);\n        }\n    }\n\n    // We want the duration of the page snap animation to be influenced by the distance that\n    // the screen has to travel, however, we don't want this duration to be effected in a\n    // purely linear fashion. Instead, we use this method to moderate the effect that the distance\n    // of travel has on the overall snap duration.\n    float distanceInfluenceForSnapDuration(float f) {\n        f -= 0.5f; // center the values about 0.\n        f *= 0.3f * Math.PI / 2.0f;\n        return (float) Math.sin(f);\n    }\n\n    /**\n     * Like {@link android.view.View#scrollBy}, but scroll smoothly instead of immediately.\n     *\n     * @param x the number of pixels to scroll by on the X axis\n     * @param y the number of pixels to scroll by on the Y axis\n     */\n    void smoothScrollTo(int x, int y) {\n        smoothScrollTo(x, y, 0);\n    }\n\n    /**\n     * Like {@link android.view.View#scrollBy}, but scroll smoothly instead of immediately.\n     *\n     * @param x the number of pixels to scroll by on the X axis\n     * @param y the number of pixels to scroll by on the Y axis\n     * @param velocity the velocity associated with a fling, if applicable. (0 otherwise)\n     */\n    void smoothScrollTo(int x, int y, int velocity) {\n        if (getChildCount() == 0) {\n            // Nothing to do.\n            setScrollingCacheEnabled(false);\n            return;\n        }\n        int sx = getScrollX();\n        int sy = getScrollY();\n        int dx = x - sx;\n        int dy = y - sy;\n        if (dx == 0 && dy == 0) {\n            completeScroll(false);\n            populate();\n            setScrollState(SCROLL_STATE_IDLE);\n            return;\n        }\n\n        setScrollingCacheEnabled(true);\n        setScrollState(SCROLL_STATE_SETTLING);\n\n        final int width = getPaddedWidth();\n        final int halfWidth = width / 2;\n        final float distanceRatio = Math.min(1f, 1.0f * Math.abs(dx) / width);\n        final float distance = halfWidth + halfWidth *\n                distanceInfluenceForSnapDuration(distanceRatio);\n\n        int duration = 0;\n        velocity = Math.abs(velocity);\n        if (velocity > 0) {\n            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));\n        } else {\n            final float pageWidth = width * mAdapter.getPageWidth(mCurItem);\n            final float pageDelta = (float) Math.abs(dx) / (pageWidth + mPageMargin);\n            duration = (int) ((pageDelta + 1) * 100);\n        }\n        duration = Math.min(duration, MAX_SETTLE_DURATION);\n\n        mScroller.startScroll(sx, sy, dx, dy, duration);\n        postInvalidateOnAnimation();\n    }\n\n    ItemInfo addNewItem(int position, int index) {\n        ItemInfo ii = new ItemInfo();\n        ii.position = position;\n        ii.object = mAdapter.instantiateItem(this, position);\n        ii.widthFactor = mAdapter.getPageWidth(position);\n        if (index < 0 || index >= mItems.size()) {\n            mItems.add(ii);\n        } else {\n            mItems.add(index, ii);\n        }\n        return ii;\n    }\n\n    void dataSetChanged() {\n        // This method only gets called if our observer is attached, so mAdapter is non-null.\n\n        final int adapterCount = mAdapter.getCount();\n        mExpectedAdapterCount = adapterCount;\n        boolean needPopulate = mItems.size() < mOffscreenPageLimit * 2 + 1 &&\n                mItems.size() < adapterCount;\n        int newCurrItem = mCurItem;\n\n        boolean isUpdating = false;\n        for (int i = 0; i < mItems.size(); i++) {\n            final ItemInfo ii = mItems.get(i);\n            final int newPos = mAdapter.getItemPosition(ii.object);\n\n            if (newPos == PagerAdapter.POSITION_UNCHANGED) {\n                continue;\n            }\n\n            if (newPos == PagerAdapter.POSITION_NONE) {\n                mItems.remove(i);\n                i--;\n\n                if (!isUpdating) {\n                    mAdapter.startUpdate(this);\n                    isUpdating = true;\n                }\n\n                mAdapter.destroyItem(this, ii.position, ii.object);\n                needPopulate = true;\n\n                if (mCurItem == ii.position) {\n                    // Keep the current item in the valid range\n                    newCurrItem = Math.max(0, Math.min(mCurItem, adapterCount - 1));\n                    needPopulate = true;\n                }\n                continue;\n            }\n\n            if (ii.position != newPos) {\n                if (ii.position == mCurItem) {\n                    // Our current item changed position. Follow it.\n                    newCurrItem = newPos;\n                }\n\n                ii.position = newPos;\n                needPopulate = true;\n            }\n        }\n\n        if (isUpdating) {\n            mAdapter.finishUpdate(this);\n        }\n\n        Collections.sort(mItems, COMPARATOR);\n\n        if (needPopulate) {\n            // Reset our known page widths; populate will recompute them.\n            final int childCount = getChildCount();\n            for (int i = 0; i < childCount; i++) {\n                final View child = getChildAt(i);\n                final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n                if (!lp.isDecor) {\n                    lp.widthFactor = 0.f;\n                }\n            }\n\n            setCurrentItemInternal(newCurrItem, false, true);\n            requestLayout();\n        }\n    }\n\n    public void populate() {\n        populate(mCurItem);\n    }\n\n    void populate(int newCurrentItem) {\n        ItemInfo oldCurInfo = null;\n        int focusDirection = View.FOCUS_FORWARD;\n        if (mCurItem != newCurrentItem) {\n            focusDirection = mCurItem < newCurrentItem ? View.FOCUS_RIGHT : View.FOCUS_LEFT;\n            oldCurInfo = infoForPosition(mCurItem);\n            mCurItem = newCurrentItem;\n        }\n\n        if (mAdapter == null) {\n            sortChildDrawingOrder();\n            return;\n        }\n\n        // Bail now if we are waiting to populate.  This is to hold off\n        // on creating views from the time the user releases their finger to\n        // fling to a new position until we have finished the scroll to\n        // that position, avoiding glitches from happening at that point.\n        if (mPopulatePending) {\n            if (DEBUG) Log.i(TAG, \"populate is pending, skipping for now...\");\n            sortChildDrawingOrder();\n            return;\n        }\n\n        // Also, don't populate until we are attached to a window.  This is to\n        // avoid trying to populate before we have restored our view hierarchy\n        // state and conflicting with what is restored.\n        if (getWindowToken() == null) {\n            return;\n        }\n        // TODO: ViewPager缓存和预加载\n        mAdapter.startUpdate(this);\n\n        final int pageLimit = mOffscreenPageLimit;\n        final int startPos = Math.max(0, mCurItem - pageLimit);\n        final int N = mAdapter.getCount();\n        final int endPos = Math.min(N-1, mCurItem + pageLimit);\n\n        if (N != mExpectedAdapterCount) {\n            String resName;\n            try {\n                resName = getResources().getResourceName(getId());\n            } catch (Resources.NotFoundException e) {\n                resName = Integer.toHexString(getId());\n            }\n            throw new IllegalStateException(\"The application's PagerAdapter changed the adapter's\" +\n                    \" contents without calling PagerAdapter#notifyDataSetChanged!\" +\n                    \" Expected adapter item count: \" + mExpectedAdapterCount + \", found: \" + N +\n                    \" Pager id: \" + resName +\n                    \" Pager class: \" + getClass() +\n                    \" Problematic adapter: \" + mAdapter.getClass());\n        }\n\n        // Locate the currently focused item or add it if needed.\n        int curIndex = -1;\n        ItemInfo curItem = null;\n        for (curIndex = 0; curIndex < mItems.size(); curIndex++) {\n            final ItemInfo ii = mItems.get(curIndex);\n            if (ii.position >= mCurItem) {\n                if (ii.position == mCurItem) curItem = ii;\n                break;\n            }\n        }\n\n        if (curItem == null && N > 0) {\n            curItem = addNewItem(mCurItem, curIndex);\n        }\n\n        // Fill 3x the available width or up to the number of offscreen\n        // pages requested to either side, whichever is larger.\n        // If we have no current item we have no work to do.\n        if (curItem != null) {\n            float extraWidthLeft = 0.f;\n            int itemIndex = curIndex - 1;\n            ItemInfo ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;\n            final int clientWidth = getPaddedWidth();\n            final float leftWidthNeeded = clientWidth <= 0 ? 0 :\n                    2.f - curItem.widthFactor + (float) getPaddingLeft() / (float) clientWidth;\n            for (int pos = mCurItem - 1; pos >= 0; pos--) {\n                if (extraWidthLeft >= leftWidthNeeded && pos < startPos) {\n                    if (ii == null) {\n                        break;\n                    }\n                    if (pos == ii.position && !ii.scrolling) {\n                        mItems.remove(itemIndex);\n                        mAdapter.destroyItem(this, pos, ii.object);\n                        if (DEBUG) {\n                            Log.i(TAG, \"populate() - destroyItem() with pos: \" + pos +\n                                    \" view: \" + ii.object);\n                        }\n                        itemIndex--;\n                        curIndex--;\n                        ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;\n                    }\n                } else if (ii != null && pos == ii.position) {\n                    extraWidthLeft += ii.widthFactor;\n                    itemIndex--;\n                    ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;\n                } else {\n                    ii = addNewItem(pos, itemIndex + 1);\n                    extraWidthLeft += ii.widthFactor;\n                    curIndex++;\n                    ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;\n                }\n            }\n\n            float extraWidthRight = curItem.widthFactor;\n            itemIndex = curIndex + 1;\n            if (extraWidthRight < 2.f) {\n                ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;\n                final float rightWidthNeeded = clientWidth <= 0 ? 0 :\n                        (float) getPaddingRight() / (float) clientWidth + 2.f;\n                for (int pos = mCurItem + 1; pos < N; pos++) {\n                    if (extraWidthRight >= rightWidthNeeded && pos > endPos) {\n                        if (ii == null) {\n                            break;\n                        }\n                        if (pos == ii.position && !ii.scrolling) {\n                            mItems.remove(itemIndex);\n                            mAdapter.destroyItem(this, pos, ii.object);\n                            if (DEBUG) {\n                                Log.i(TAG, \"populate() - destroyItem() with pos: \" + pos +\n                                        \" view: \" + ii.object);\n                            }\n                            ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;\n                        }\n                    } else if (ii != null && pos == ii.position) {\n                        extraWidthRight += ii.widthFactor;\n                        itemIndex++;\n                        ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;\n                    } else {\n                        ii = addNewItem(pos, itemIndex);\n                        itemIndex++;\n                        extraWidthRight += ii.widthFactor;\n                        ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;\n                    }\n                }\n            }\n\n            calculatePageOffsets(curItem, curIndex, oldCurInfo);\n        }\n\n        if (DEBUG) {\n            Log.i(TAG, \"Current page list:\");\n            for (int i=0; i<mItems.size(); i++) {\n                Log.i(TAG, \"#\" + i + \": page \" + mItems.get(i).position);\n            }\n        }\n\n        mAdapter.setPrimaryItem(this, mCurItem, curItem != null ? curItem.object : null);\n\n        mAdapter.finishUpdate(this);\n\n        // Check width measurement of current pages and drawing sort order.\n        // Update LayoutParams as needed.\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n            lp.childIndex = i;\n            if (!lp.isDecor && lp.widthFactor == 0.f) {\n                // 0 means requery the adapter for this, it doesn't have a valid width.\n                final ItemInfo ii = infoForChild(child);\n                if (ii != null) {\n                    lp.widthFactor = ii.widthFactor;\n                    lp.position = ii.position;\n                }\n            }\n        }\n        sortChildDrawingOrder();\n\n        if (hasFocus()) {\n            View currentFocused = findFocus();\n            ItemInfo ii = currentFocused != null ? infoForAnyChild(currentFocused) : null;\n            if (ii == null || ii.position != mCurItem) {\n                for (int i=0; i<getChildCount(); i++) {\n                    View child = getChildAt(i);\n                    ii = infoForChild(child);\n                    if (ii != null && ii.position == mCurItem) {\n                        final Rect focusRect;\n                        if (currentFocused == null) {\n                            focusRect = null;\n                        } else {\n                            focusRect = mTempRect;\n                            currentFocused.getFocusedRect(mTempRect);\n                            offsetDescendantRectToMyCoords(currentFocused, mTempRect);\n                            offsetRectIntoDescendantCoords(child, mTempRect);\n                        }\n                        if (child.requestFocus(focusDirection, focusRect)) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private void sortChildDrawingOrder() {\n        if (mDrawingOrder != DRAW_ORDER_DEFAULT) {\n            if (mDrawingOrderedChildren == null) {\n                mDrawingOrderedChildren = new ArrayList<View>();\n            } else {\n                mDrawingOrderedChildren.clear();\n            }\n            final int childCount = getChildCount();\n            for (int i = 0; i < childCount; i++) {\n                final View child = getChildAt(i);\n                mDrawingOrderedChildren.add(child);\n            }\n            Collections.sort(mDrawingOrderedChildren, sPositionComparator);\n        }\n    }\n\n    private void calculatePageOffsets(ItemInfo curItem, int curIndex, ItemInfo oldCurInfo) {\n        final int N = mAdapter.getCount();\n        final int width = getPaddedWidth();\n        final float marginOffset = width > 0 ? (float) mPageMargin / width : 0;\n\n        // Fix up offsets for later layout.\n        if (oldCurInfo != null) {\n            final int oldCurPosition = oldCurInfo.position;\n\n            // Base offsets off of oldCurInfo.\n            if (oldCurPosition < curItem.position) {\n                int itemIndex = 0;\n                float offset = oldCurInfo.offset + oldCurInfo.widthFactor + marginOffset;\n                for (int pos = oldCurPosition + 1; pos <= curItem.position && itemIndex < mItems.size(); pos++) {\n                    ItemInfo ii = mItems.get(itemIndex);\n                    while (pos > ii.position && itemIndex < mItems.size() - 1) {\n                        itemIndex++;\n                        ii = mItems.get(itemIndex);\n                    }\n\n                    while (pos < ii.position) {\n                        // We don't have an item populated for this,\n                        // ask the adapter for an offset.\n                        offset += mAdapter.getPageWidth(pos) + marginOffset;\n                        pos++;\n                    }\n\n                    ii.offset = offset;\n                    offset += ii.widthFactor + marginOffset;\n                }\n            } else if (oldCurPosition > curItem.position) {\n                int itemIndex = mItems.size() - 1;\n                float offset = oldCurInfo.offset;\n                for (int pos = oldCurPosition - 1; pos >= curItem.position && itemIndex >= 0; pos--) {\n                    ItemInfo ii = mItems.get(itemIndex);\n                    while (pos < ii.position && itemIndex > 0) {\n                        itemIndex--;\n                        ii = mItems.get(itemIndex);\n                    }\n\n                    while (pos > ii.position) {\n                        // We don't have an item populated for this,\n                        // ask the adapter for an offset.\n                        offset -= mAdapter.getPageWidth(pos) + marginOffset;\n                        pos--;\n                    }\n\n                    offset -= ii.widthFactor + marginOffset;\n                    ii.offset = offset;\n                }\n            }\n        }\n\n        // Base all offsets off of curItem.\n        final int itemCount = mItems.size();\n        float offset = curItem.offset;\n        int pos = curItem.position - 1;\n        mFirstOffset = curItem.position == 0 ? curItem.offset : -Float.MAX_VALUE;\n        mLastOffset = curItem.position == N - 1 ?\n                curItem.offset + curItem.widthFactor - 1 : Float.MAX_VALUE;\n\n        // Previous pages\n        for (int i = curIndex - 1; i >= 0; i--, pos--) {\n            final ItemInfo ii = mItems.get(i);\n            while (pos > ii.position) {\n                offset -= mAdapter.getPageWidth(pos--) + marginOffset;\n            }\n            offset -= ii.widthFactor + marginOffset;\n            ii.offset = offset;\n            if (ii.position == 0) mFirstOffset = offset;\n        }\n\n        offset = curItem.offset + curItem.widthFactor + marginOffset;\n        pos = curItem.position + 1;\n\n        // Next pages\n        for (int i = curIndex + 1; i < itemCount; i++, pos++) {\n            final ItemInfo ii = mItems.get(i);\n            while (pos < ii.position) {\n                offset += mAdapter.getPageWidth(pos++) + marginOffset;\n            }\n            if (ii.position == N - 1) {\n                mLastOffset = offset + ii.widthFactor - 1;\n            }\n            ii.offset = offset;\n            offset += ii.widthFactor + marginOffset;\n        }\n    }\n\n    /**\n     * This is the persistent state that is saved by ViewPager.  Only needed\n     * if you are creating a sublass of ViewPager that must save its own\n     * state, in which case it should implement a subclass of this which\n     * contains that state.\n     */\n    public static class SavedState extends AbsSavedState {\n        int position;\n        Parcelable adapterState;\n        ClassLoader loader;\n\n        public SavedState(@NonNull Parcelable superState) {\n            super(superState);\n        }\n\n        @Override\n        public void writeToParcel(Parcel out, int flags) {\n            super.writeToParcel(out, flags);\n            out.writeInt(position);\n            out.writeParcelable(adapterState, flags);\n        }\n\n        @Override\n        public String toString() {\n            return \"FragmentPager.SavedState{\"\n                    + Integer.toHexString(System.identityHashCode(this))\n                    + \" position=\" + position + \"}\";\n        }\n\n        public static final Creator<SavedState> CREATOR = new ClassLoaderCreator<SavedState>() {\n            @Override\n            public SavedState createFromParcel(Parcel in, ClassLoader loader) {\n                return new SavedState(in, loader);\n            }\n\n            @Override\n            public SavedState createFromParcel(Parcel in) {\n                return new SavedState(in, null);\n            }\n            @Override\n            public SavedState[] newArray(int size) {\n                return new SavedState[size];\n            }\n        };\n\n        SavedState(Parcel in, ClassLoader loader) {\n            super(in, loader);\n            if (loader == null) {\n                loader = getClass().getClassLoader();\n            }\n            position = in.readInt();\n            adapterState = in.readParcelable(loader);\n            this.loader = loader;\n        }\n    }\n\n    @Override\n    public Parcelable onSaveInstanceState() {\n        Parcelable superState = super.onSaveInstanceState();\n        SavedState ss = new SavedState(superState);\n        ss.position = mCurItem;\n        if (mAdapter != null) {\n            ss.adapterState = mAdapter.saveState();\n        }\n        return ss;\n    }\n\n    @Override\n    public void onRestoreInstanceState(Parcelable state) {\n        if (!(state instanceof SavedState)) {\n            super.onRestoreInstanceState(state);\n            return;\n        }\n\n        SavedState ss = (SavedState)state;\n        super.onRestoreInstanceState(ss.getSuperState());\n\n        if (mAdapter != null) {\n            mAdapter.restoreState(ss.adapterState, ss.loader);\n            setCurrentItemInternal(ss.position, false, true);\n        } else {\n            mRestoredCurItem = ss.position;\n            mRestoredAdapterState = ss.adapterState;\n            mRestoredClassLoader = ss.loader;\n        }\n    }\n\n    @Override\n    public void addView(View child, int index, ViewGroup.LayoutParams params) {\n        if (!checkLayoutParams(params)) {\n            params = generateLayoutParams(params);\n        }\n        final LayoutParams lp = (LayoutParams) params;\n        lp.isDecor |= child instanceof Decor;\n        if (mInLayout) {\n            if (lp != null && lp.isDecor) {\n                throw new IllegalStateException(\"Cannot add pager decor view during layout\");\n            }\n            lp.needsMeasure = true;\n            addViewInLayout(child, index, params);\n        } else {\n            super.addView(child, index, params);\n        }\n\n        if (USE_CACHE) {\n            if (child.getVisibility() != GONE) {\n                child.setDrawingCacheEnabled(mScrollingCacheEnabled);\n            } else {\n                child.setDrawingCacheEnabled(false);\n            }\n        }\n    }\n\n    public Object getCurrent() {\n        final ItemInfo itemInfo = infoForPosition(getCurrentItem());\n        return itemInfo == null ? null : itemInfo.object;\n    }\n\n    @Override\n    public void removeView(View view) {\n        if (mInLayout) {\n            removeViewInLayout(view);\n        } else {\n            super.removeView(view);\n        }\n    }\n\n    ItemInfo infoForChild(View child) {\n        for (int i=0; i<mItems.size(); i++) {\n            ItemInfo ii = mItems.get(i);\n            if (mAdapter.isViewFromObject(child, ii.object)) {\n                return ii;\n            }\n        }\n        return null;\n    }\n\n    ItemInfo infoForAnyChild(View child) {\n        ViewParent parent;\n        while ((parent=child.getParent()) != this) {\n            if (parent == null || !(parent instanceof View)) {\n                return null;\n            }\n            child = (View)parent;\n        }\n        return infoForChild(child);\n    }\n\n    ItemInfo infoForPosition(int position) {\n        for (int i = 0; i < mItems.size(); i++) {\n            ItemInfo ii = mItems.get(i);\n            if (ii.position == position) {\n                return ii;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    protected void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        mFirstLayout = true;\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // For simple implementation, our internal size is always 0.\n        // We depend on the container to specify the layout size of\n        // our view.  We can't really know what it is since we will be\n        // adding and removing different arbitrary views and do not\n        // want the layout to change as this happens.\n        setMeasuredDimension(getDefaultSize(0, widthMeasureSpec),\n                getDefaultSize(0, heightMeasureSpec));\n\n        final int measuredWidth = getMeasuredWidth();\n        final int maxGutterSize = measuredWidth / 10;\n        mGutterSize = Math.min(maxGutterSize, mDefaultGutterSize);\n\n        // Children are just made to fill our space.\n        int childWidthSize = measuredWidth - getPaddingLeft() - getPaddingRight();\n        int childHeightSize = getMeasuredHeight() - getPaddingTop() - getPaddingBottom();\n\n        /*\n         * Make sure all children have been properly measured. Decor views first.\n         * Right now we cheat and make this less complicated by assuming decor\n         * views won't intersect. We will pin to edges based on gravity.\n         */\n        int size = getChildCount();\n        for (int i = 0; i < size; ++i) {\n            final View child = getChildAt(i);\n            if (child.getVisibility() != GONE) {\n                final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n                if (lp != null && lp.isDecor) {\n                    final int hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;\n                    final int vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;\n                    int widthMode = MeasureSpec.AT_MOST;\n                    int heightMode = MeasureSpec.AT_MOST;\n                    boolean consumeVertical = vgrav == Gravity.TOP || vgrav == Gravity.BOTTOM;\n                    boolean consumeHorizontal = hgrav == Gravity.LEFT || hgrav == Gravity.RIGHT;\n\n                    if (consumeVertical) {\n                        widthMode = MeasureSpec.EXACTLY;\n                    } else if (consumeHorizontal) {\n                        heightMode = MeasureSpec.EXACTLY;\n                    }\n\n                    int widthSize = childWidthSize;\n                    int heightSize = childHeightSize;\n                    if (lp.width != LayoutParams.WRAP_CONTENT) {\n                        widthMode = MeasureSpec.EXACTLY;\n                        if (lp.width != LayoutParams.FILL_PARENT) {\n                            widthSize = lp.width;\n                        }\n                    }\n                    if (lp.height != LayoutParams.WRAP_CONTENT) {\n                        heightMode = MeasureSpec.EXACTLY;\n                        if (lp.height != LayoutParams.FILL_PARENT) {\n                            heightSize = lp.height;\n                        }\n                    }\n                    final int widthSpec = MeasureSpec.makeMeasureSpec(widthSize, widthMode);\n                    final int heightSpec = MeasureSpec.makeMeasureSpec(heightSize, heightMode);\n                    child.measure(widthSpec, heightSpec);\n\n                    if (consumeVertical) {\n                        childHeightSize -= child.getMeasuredHeight();\n                    } else if (consumeHorizontal) {\n                        childWidthSize -= child.getMeasuredWidth();\n                    }\n                }\n            }\n        }\n\n        mChildWidthMeasureSpec = MeasureSpec.makeMeasureSpec(childWidthSize, MeasureSpec.EXACTLY);\n        mChildHeightMeasureSpec = MeasureSpec.makeMeasureSpec(childHeightSize, MeasureSpec.EXACTLY);\n\n        // Make sure we have created all fragments that we need to have shown.\n        mInLayout = true;\n        populate();\n        mInLayout = false;\n\n        // Page views next.\n        size = getChildCount();\n        for (int i = 0; i < size; ++i) {\n            final View child = getChildAt(i);\n            if (child.getVisibility() != GONE) {\n                if (DEBUG) Log.v(TAG, \"Measuring #\" + i + \" \" + child\n                        + \": \" + mChildWidthMeasureSpec);\n\n                final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n                if (lp == null || !lp.isDecor) {\n                    final int widthSpec = MeasureSpec.makeMeasureSpec(\n                            (int) (childWidthSize * lp.widthFactor), MeasureSpec.EXACTLY);\n                    child.measure(widthSpec, mChildHeightMeasureSpec);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n\n        // Make sure scroll position is set correctly.\n        if (w != oldw) {\n            recomputeScrollPosition(w, oldw, mPageMargin, mPageMargin);\n        }\n    }\n\n    private void recomputeScrollPosition(int width, int oldWidth, int margin, int oldMargin) {\n        if (oldWidth > 0 && !mItems.isEmpty()) {\n            final int widthWithMargin = width - getPaddingLeft() - getPaddingRight() + margin;\n            final int oldWidthWithMargin = oldWidth - getPaddingLeft() - getPaddingRight()\n                                           + oldMargin;\n            final int xpos = getScrollX();\n            final float pageOffset = (float) xpos / oldWidthWithMargin;\n            final int newOffsetPixels = (int) (pageOffset * widthWithMargin);\n\n            scrollTo(newOffsetPixels, getScrollY());\n            if (!mScroller.isFinished()) {\n                // We now return to your regularly scheduled scroll, already in progress.\n                final int newDuration = mScroller.getDuration() - mScroller.timePassed();\n                ItemInfo targetInfo = infoForPosition(mCurItem);\n                mScroller.startScroll(newOffsetPixels, 0,\n                        (int) (targetInfo.offset * width), 0, newDuration);\n            }\n        } else {\n            final ItemInfo ii = infoForPosition(mCurItem);\n            final float scrollOffset = ii != null ? Math.min(ii.offset, mLastOffset) : 0;\n            final int scrollPos = (int) (scrollOffset *\n                                         (width - getPaddingLeft() - getPaddingRight()));\n            if (scrollPos != getScrollX()) {\n                completeScroll(false);\n                scrollTo(scrollPos, getScrollY());\n            }\n        }\n    }\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        final int count = getChildCount();\n        int width = r - l;\n        int height = b - t;\n        int paddingLeft = getPaddingLeft();\n        int paddingTop = getPaddingTop();\n        int paddingRight = getPaddingRight();\n        int paddingBottom = getPaddingBottom();\n        final int scrollX = getScrollX();\n\n        int decorCount = 0;\n\n        // First pass - decor views. We need to do this in two passes so that\n        // we have the proper offsets for non-decor views later.\n        for (int i = 0; i < count; i++) {\n            final View child = getChildAt(i);\n            if (child.getVisibility() != GONE) {\n                final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n                int childLeft = 0;\n                int childTop = 0;\n                if (lp.isDecor) {\n                    final int hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;\n                    final int vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;\n                    switch (hgrav) {\n                        default:\n                            childLeft = paddingLeft;\n                            break;\n                        case Gravity.LEFT:\n                            childLeft = paddingLeft;\n                            paddingLeft += child.getMeasuredWidth();\n                            break;\n                        case Gravity.CENTER_HORIZONTAL:\n                            childLeft = Math.max((width - child.getMeasuredWidth()) / 2,\n                                    paddingLeft);\n                            break;\n                        case Gravity.RIGHT:\n                            childLeft = width - paddingRight - child.getMeasuredWidth();\n                            paddingRight += child.getMeasuredWidth();\n                            break;\n                    }\n                    switch (vgrav) {\n                        default:\n                            childTop = paddingTop;\n                            break;\n                        case Gravity.TOP:\n                            childTop = paddingTop;\n                            paddingTop += child.getMeasuredHeight();\n                            break;\n                        case Gravity.CENTER_VERTICAL:\n                            childTop = Math.max((height - child.getMeasuredHeight()) / 2,\n                                    paddingTop);\n                            break;\n                        case Gravity.BOTTOM:\n                            childTop = height - paddingBottom - child.getMeasuredHeight();\n                            paddingBottom += child.getMeasuredHeight();\n                            break;\n                    }\n                    childLeft += scrollX;\n                    child.layout(childLeft, childTop,\n                            childLeft + child.getMeasuredWidth(),\n                            childTop + child.getMeasuredHeight());\n                    decorCount++;\n                }\n            }\n        }\n\n        final int childWidth = width - paddingLeft - paddingRight;\n        // Page views. Do this once we have the right padding offsets from above.\n        for (int i = 0; i < count; i++) {\n            final View child = getChildAt(i);\n            if (child.getVisibility() == GONE) {\n                continue;\n            }\n\n            final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n            if (lp.isDecor) {\n                continue;\n            }\n\n            final ItemInfo ii = infoForChild(child);\n            if (ii == null) {\n                continue;\n            }\n\n            if (lp.needsMeasure) {\n                // This was added during layout and needs measurement.\n                // Do it now that we know what we're working with.\n                lp.needsMeasure = false;\n                final int widthSpec = MeasureSpec.makeMeasureSpec(\n                        (int) (childWidth * lp.widthFactor),\n                        MeasureSpec.EXACTLY);\n                final int heightSpec = MeasureSpec.makeMeasureSpec(\n                        (int) (height - paddingTop - paddingBottom),\n                        MeasureSpec.EXACTLY);\n                child.measure(widthSpec, heightSpec);\n            }\n\n            final int childMeasuredWidth = child.getMeasuredWidth();\n            final int startOffset = (int) (childWidth * ii.offset);\n            final int childLeft;\n            if (isLayoutRtl()) {\n                childLeft = MAX_SCROLL_X - paddingRight - startOffset - childMeasuredWidth;\n            } else {\n                childLeft = paddingLeft + startOffset;\n            }\n\n            final int childTop = paddingTop;\n            child.layout(childLeft, childTop, childLeft + childMeasuredWidth,\n                    childTop + child.getMeasuredHeight());\n        }\n\n        mTopPageBounds = paddingTop;\n        mBottomPageBounds = height - paddingBottom;\n        mDecorChildCount = decorCount;\n\n        if (mFirstLayout) {\n            scrollToItem(mCurItem, false, 0, false);\n        }\n        mFirstLayout = false;\n    }\n\n    @Override\n    public void computeScroll() {\n        if (!mScroller.isFinished() && mScroller.computeScrollOffset()) {\n            final int oldX = getScrollX();\n            final int oldY = getScrollY();\n            final int x = mScroller.getCurrX();\n            final int y = mScroller.getCurrY();\n\n            if (oldX != x || oldY != y) {\n                scrollTo(x, y);\n\n                if (!pageScrolled(x)) {\n                    mScroller.abortAnimation();\n                    scrollTo(0, y);\n                }\n            }\n\n            // Keep on drawing until the animation has finished.\n            postInvalidateOnAnimation();\n            return;\n        }\n\n        // Done with scroll, clean up state.\n        completeScroll(true);\n    }\n\n    private boolean pageScrolled(int scrollX) {\n        if (mItems.size() == 0) {\n            mCalledSuper = false;\n            onPageScrolled(0, 0, 0);\n            if (!mCalledSuper) {\n                throw new IllegalStateException(\n                        \"onPageScrolled did not call superclass implementation\");\n            }\n            return false;\n        }\n\n        // Translate to scrollX to scrollStart for RTL.\n        final int scrollStart;\n        if (isLayoutRtl()) {\n            scrollStart = MAX_SCROLL_X - scrollX;\n        } else {\n            scrollStart = scrollX;\n        }\n\n        final ItemInfo ii = infoForFirstVisiblePage();\n        final int width = getPaddedWidth();\n        final int widthWithMargin = width + mPageMargin;\n        final float marginOffset = (float) mPageMargin / width;\n        final int currentPage = ii.position;\n        final float pageOffset = (((float) scrollStart / width) - ii.offset) /\n                (ii.widthFactor + marginOffset);\n        final int offsetPixels = (int) (pageOffset * widthWithMargin);\n\n        mCalledSuper = false;\n        onPageScrolled(currentPage, pageOffset, offsetPixels);\n        if (!mCalledSuper) {\n            throw new IllegalStateException(\n                    \"onPageScrolled did not call superclass implementation\");\n        }\n        return true;\n    }\n\n    /**\n     * This method will be invoked when the current page is scrolled, either as part\n     * of a programmatically initiated smooth scroll or a user initiated touch scroll.\n     * If you override this method you must call through to the superclass implementation\n     * (e.g. super.onPageScrolled(position, offset, offsetPixels)) before onPageScrolled\n     * returns.\n     *\n     * @param position Position index of the first page currently being displayed.\n     *                 Page position+1 will be visible if positionOffset is nonzero.\n     * @param offset Value from [0, 1) indicating the offset from the page at position.\n     * @param offsetPixels Value in pixels indicating the offset from position.\n     */\n    protected void onPageScrolled(int position, float offset, int offsetPixels) {\n        // Offset any decor views if needed - keep them on-screen at all times.\n        if (mDecorChildCount > 0) {\n            final int scrollX = getScrollX();\n            int paddingLeft = getPaddingLeft();\n            int paddingRight = getPaddingRight();\n            final int width = getWidth();\n            final int childCount = getChildCount();\n            for (int i = 0; i < childCount; i++) {\n                final View child = getChildAt(i);\n                final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n                if (!lp.isDecor) continue;\n\n                final int hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;\n                int childLeft = 0;\n                switch (hgrav) {\n                    default:\n                        childLeft = paddingLeft;\n                        break;\n                    case Gravity.LEFT:\n                        childLeft = paddingLeft;\n                        paddingLeft += child.getWidth();\n                        break;\n                    case Gravity.CENTER_HORIZONTAL:\n                        childLeft = Math.max((width - child.getMeasuredWidth()) / 2,\n                                paddingLeft);\n                        break;\n                    case Gravity.RIGHT:\n                        childLeft = width - paddingRight - child.getMeasuredWidth();\n                        paddingRight += child.getMeasuredWidth();\n                        break;\n                }\n                childLeft += scrollX;\n\n                final int childOffset = childLeft - child.getLeft();\n                if (childOffset != 0) {\n                    child.offsetLeftAndRight(childOffset);\n                }\n            }\n        }\n\n        if (mOnPageChangeListener != null) {\n            mOnPageChangeListener.onPageScrolled(position, offset, offsetPixels);\n        }\n        if (mInternalPageChangeListener != null) {\n            mInternalPageChangeListener.onPageScrolled(position, offset, offsetPixels);\n        }\n\n        if (mPageTransformer != null) {\n            final int scrollX = getScrollX();\n            final int childCount = getChildCount();\n            for (int i = 0; i < childCount; i++) {\n                final View child = getChildAt(i);\n                final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n\n                if (lp.isDecor) continue;\n\n                final float transformPos = (float) (child.getLeft() - scrollX) / getPaddedWidth();\n                mPageTransformer.transformPage(child, transformPos);\n            }\n        }\n\n        mCalledSuper = true;\n    }\n\n    private void completeScroll(boolean postEvents) {\n        boolean needPopulate = mScrollState == SCROLL_STATE_SETTLING;\n        if (needPopulate) {\n            // Done with scroll, no longer want to cache view drawing.\n            setScrollingCacheEnabled(false);\n            mScroller.abortAnimation();\n            int oldX = getScrollX();\n            int oldY = getScrollY();\n            int x = mScroller.getCurrX();\n            int y = mScroller.getCurrY();\n            if (oldX != x || oldY != y) {\n                scrollTo(x, y);\n            }\n        }\n        mPopulatePending = false;\n        for (int i=0; i<mItems.size(); i++) {\n            ItemInfo ii = mItems.get(i);\n            if (ii.scrolling) {\n                needPopulate = true;\n                ii.scrolling = false;\n            }\n        }\n        if (needPopulate) {\n            if (postEvents) {\n                postOnAnimation(mEndScrollRunnable);\n            } else {\n                mEndScrollRunnable.run();\n            }\n        }\n    }\n\n    private boolean isGutterDrag(float x, float dx) {\n        return (x < mGutterSize && dx > 0) || (x > getWidth() - mGutterSize && dx < 0);\n    }\n\n    private void enableLayers(boolean enable) {\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final int layerType = enable ? LAYER_TYPE_HARDWARE : LAYER_TYPE_NONE;\n            getChildAt(i).setLayerType(layerType, null);\n        }\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        /*\n         * This method JUST determines whether we want to intercept the motion.\n         * If we return true, onMotionEvent will be called and we do the actual\n         * scrolling there.\n         */\n\n        final int action = ev.getAction() & MotionEvent.ACTION_MASK;\n\n        // Always take care of the touch gesture being complete.\n        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {\n            // Release the drag.\n            if (DEBUG) Log.v(TAG, \"Intercept done!\");\n            mIsBeingDragged = false;\n            mIsUnableToDrag = false;\n            mActivePointerId = INVALID_POINTER;\n            if (mVelocityTracker != null) {\n                mVelocityTracker.recycle();\n                mVelocityTracker = null;\n            }\n            return false;\n        }\n\n        // Nothing more to do here if we have decided whether or not we\n        // are dragging.\n        if (action != MotionEvent.ACTION_DOWN) {\n            if (mIsBeingDragged) {\n                if (DEBUG) Log.v(TAG, \"Being dragged, intercept returning true!\");\n                return true;\n            }\n            if (mIsUnableToDrag) {\n                if (DEBUG) Log.v(TAG, \"Unable to drag, intercept returning false!\");\n                return false;\n            }\n        }\n\n        switch (action) {\n            case MotionEvent.ACTION_MOVE: {\n                /*\n                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check\n                 * whether the user has moved far enough from his original down touch.\n                 */\n\n                /*\n                * Locally do absolute value. mLastMotionY is set to the y value\n                * of the down event.\n                */\n                final int activePointerId = mActivePointerId;\n                if (activePointerId == INVALID_POINTER) {\n                    // If we don't have a valid id, the touch down wasn't on content.\n                    break;\n                }\n\n                final int pointerIndex = ev.findPointerIndex(activePointerId);\n                final float x = ev.getX(pointerIndex);\n                final float dx = x - mLastMotionX;\n                final float xDiff = Math.abs(dx);\n                final float y = ev.getY(pointerIndex);\n                final float yDiff = Math.abs(y - mInitialMotionY);\n                if (DEBUG) Log.v(TAG, \"Moved x to \" + x + \",\" + y + \" diff=\" + xDiff + \",\" + yDiff);\n\n                if (dx != 0 && !isGutterDrag(mLastMotionX, dx) &&\n                        canScroll(this, false, (int) dx, (int) x, (int) y)) {\n                    // Nested view has scrollable area under this point. Let it be handled there.\n                    mLastMotionX = x;\n                    mLastMotionY = y;\n                    mIsUnableToDrag = true;\n                    return false;\n                }\n                if (xDiff > mTouchSlop && xDiff * 0.5f > yDiff) {\n                    if (DEBUG) Log.v(TAG, \"Starting drag!\");\n                    mIsBeingDragged = true;\n                    requestParentDisallowInterceptTouchEvent(true);\n                    setScrollState(SCROLL_STATE_DRAGGING);\n                    mLastMotionX = dx > 0 ? mInitialMotionX + mTouchSlop :\n                            mInitialMotionX - mTouchSlop;\n                    mLastMotionY = y;\n                    setScrollingCacheEnabled(true);\n                } else if (yDiff > mTouchSlop) {\n                    // The finger has moved enough in the vertical\n                    // direction to be counted as a drag...  abort\n                    // any attempt to drag horizontally, to work correctly\n                    // with children that have scrolling containers.\n                    if (DEBUG) Log.v(TAG, \"Starting unable to drag!\");\n                    mIsUnableToDrag = true;\n                }\n                if (mIsBeingDragged) {\n                    // Scroll to follow the motion event\n                    if (performDrag(x)) {\n                        postInvalidateOnAnimation();\n                    }\n                }\n                break;\n            }\n\n            case MotionEvent.ACTION_DOWN: {\n                /*\n                 * Remember location of down touch.\n                 * ACTION_DOWN always refers to pointer index 0.\n                 */\n                mLastMotionX = mInitialMotionX = ev.getX();\n                mLastMotionY = mInitialMotionY = ev.getY();\n                mActivePointerId = ev.getPointerId(0);\n                mIsUnableToDrag = false;\n\n                mScroller.computeScrollOffset();\n                if (mScrollState == SCROLL_STATE_SETTLING &&\n                        Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) > mCloseEnough) {\n                    // Let the user 'catch' the pager as it animates.\n                    mScroller.abortAnimation();\n                    mPopulatePending = false;\n                    populate();\n                    mIsBeingDragged = true;\n                    requestParentDisallowInterceptTouchEvent(true);\n                    setScrollState(SCROLL_STATE_DRAGGING);\n                } else {\n                    completeScroll(false);\n                    mIsBeingDragged = false;\n                }\n\n                if (DEBUG) Log.v(TAG, \"Down at \" + mLastMotionX + \",\" + mLastMotionY\n                        + \" mIsBeingDragged=\" + mIsBeingDragged\n                        + \"mIsUnableToDrag=\" + mIsUnableToDrag);\n                break;\n            }\n\n            case MotionEvent.ACTION_POINTER_UP:\n                onSecondaryPointerUp(ev);\n                break;\n        }\n\n        if (mVelocityTracker == null) {\n            mVelocityTracker = VelocityTracker.obtain();\n        }\n        mVelocityTracker.addMovement(ev);\n\n        /*\n         * The only time we want to intercept motion events is if we are in the\n         * drag mode.\n         */\n        return mIsBeingDragged;\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent ev) {\n        if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {\n            // Don't handle edge touches immediately -- they may actually belong to one of our\n            // descendants.\n            return false;\n        }\n\n        if (mAdapter == null || mAdapter.getCount() == 0) {\n            // Nothing to present or scroll; nothing to touch.\n            return false;\n        }\n\n        if (mVelocityTracker == null) {\n            mVelocityTracker = VelocityTracker.obtain();\n        }\n        mVelocityTracker.addMovement(ev);\n\n        final int action = ev.getAction();\n        boolean needsInvalidate = false;\n\n        switch (action & MotionEvent.ACTION_MASK) {\n            case MotionEvent.ACTION_DOWN: {\n                mScroller.abortAnimation();\n                mPopulatePending = false;\n                populate();\n\n                // Remember where the motion event started\n                mLastMotionX = mInitialMotionX = ev.getX();\n                mLastMotionY = mInitialMotionY = ev.getY();\n                mActivePointerId = ev.getPointerId(0);\n                break;\n            }\n            case MotionEvent.ACTION_MOVE:\n                if (!mIsBeingDragged) {\n                    final int pointerIndex = ev.findPointerIndex(mActivePointerId);\n                    final float x = ev.getX(pointerIndex);\n                    final float xDiff = Math.abs(x - mLastMotionX);\n                    final float y = ev.getY(pointerIndex);\n                    final float yDiff = Math.abs(y - mLastMotionY);\n                    if (DEBUG) Log.v(TAG, \"Moved x to \" + x + \",\" + y + \" diff=\" + xDiff + \",\" + yDiff);\n                    if (xDiff > mTouchSlop && xDiff > yDiff) {\n                        if (DEBUG) Log.v(TAG, \"Starting drag!\");\n                        mIsBeingDragged = true;\n                        requestParentDisallowInterceptTouchEvent(true);\n                        mLastMotionX = x - mInitialMotionX > 0 ? mInitialMotionX + mTouchSlop :\n                                mInitialMotionX - mTouchSlop;\n                        mLastMotionY = y;\n                        setScrollState(SCROLL_STATE_DRAGGING);\n                        setScrollingCacheEnabled(true);\n\n                        // Disallow Parent Intercept, just in case\n                        ViewParent parent = getParent();\n                        if (parent != null) {\n                            parent.requestDisallowInterceptTouchEvent(true);\n                        }\n                    }\n                }\n                // Not else! Note that mIsBeingDragged can be set above.\n                if (mIsBeingDragged) {\n                    // Scroll to follow the motion event\n                    final int activePointerIndex = ev.findPointerIndex(mActivePointerId);\n                    final float x = ev.getX(activePointerIndex);\n                    needsInvalidate |= performDrag(x);\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                if (mIsBeingDragged) {\n                    final VelocityTracker velocityTracker = mVelocityTracker;\n                    velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n                    final int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);\n\n                    mPopulatePending = true;\n\n                    final float scrollStart = getScrollStart();\n                    final float scrolledPages = scrollStart / getPaddedWidth();\n                    final ItemInfo ii = infoForFirstVisiblePage();\n                    final int currentPage = ii.position;\n                    final float nextPageOffset;\n                    if (isLayoutRtl()) {\n                        nextPageOffset = (ii.offset - scrolledPages) / ii.widthFactor;\n                    }  else {\n                        nextPageOffset = (scrolledPages - ii.offset) / ii.widthFactor;\n                    }\n\n                    final int activePointerIndex = ev.findPointerIndex(mActivePointerId);\n                    final float x = ev.getX(activePointerIndex);\n                    final int totalDelta = (int) (x - mInitialMotionX);\n                    final int nextPage = determineTargetPage(\n                            currentPage, nextPageOffset, initialVelocity, totalDelta);\n                    setCurrentItemInternal(nextPage, true, true, initialVelocity);\n\n                    mActivePointerId = INVALID_POINTER;\n                    endDrag();\n                    mLeftEdge.onRelease();\n                    mRightEdge.onRelease();\n                    needsInvalidate = true;\n                }\n                break;\n            case MotionEvent.ACTION_CANCEL:\n                if (mIsBeingDragged) {\n                    scrollToItem(mCurItem, true, 0, false);\n                    mActivePointerId = INVALID_POINTER;\n                    endDrag();\n                    mLeftEdge.onRelease();\n                    mRightEdge.onRelease();\n                    needsInvalidate = true;\n                }\n                break;\n            case MotionEvent.ACTION_POINTER_DOWN: {\n                final int index = ev.getActionIndex();\n                final float x = ev.getX(index);\n                mLastMotionX = x;\n                mActivePointerId = ev.getPointerId(index);\n                break;\n            }\n            case MotionEvent.ACTION_POINTER_UP:\n                onSecondaryPointerUp(ev);\n                mLastMotionX = ev.getX(ev.findPointerIndex(mActivePointerId));\n                break;\n        }\n        if (needsInvalidate) {\n            postInvalidateOnAnimation();\n        }\n        return true;\n    }\n\n    private void requestParentDisallowInterceptTouchEvent(boolean disallowIntercept) {\n        final ViewParent parent = getParent();\n        if (parent != null) {\n            parent.requestDisallowInterceptTouchEvent(disallowIntercept);\n        }\n    }\n\n    private boolean performDrag(float x) {\n        boolean needsInvalidate = false;\n\n        final int width = getPaddedWidth();\n        final float deltaX = mLastMotionX - x;\n        mLastMotionX = x;\n\n        final EdgeEffect startEdge;\n        final EdgeEffect endEdge;\n        if (isLayoutRtl()) {\n            startEdge = mRightEdge;\n            endEdge = mLeftEdge;\n        } else {\n            startEdge = mLeftEdge;\n            endEdge = mRightEdge;\n        }\n\n        // Translate scroll to relative coordinates.\n        final float nextScrollX = getScrollX() + deltaX;\n        final float scrollStart;\n        if (isLayoutRtl()) {\n            scrollStart = MAX_SCROLL_X - nextScrollX;\n        } else {\n            scrollStart = nextScrollX;\n        }\n\n        final float startBound;\n        final ItemInfo startItem = mItems.get(0);\n        final boolean startAbsolute = startItem.position == 0;\n        if (startAbsolute) {\n            startBound = startItem.offset * width;\n        } else {\n            startBound = width * mFirstOffset;\n        }\n\n        final float endBound;\n        final ItemInfo endItem = mItems.get(mItems.size() - 1);\n        final boolean endAbsolute = endItem.position == mAdapter.getCount() - 1;\n        if (endAbsolute) {\n            endBound = endItem.offset * width;\n        } else {\n            endBound = width * mLastOffset;\n        }\n\n        final float clampedScrollStart;\n        if (scrollStart < startBound) {\n            if (startAbsolute) {\n                final float over = startBound - scrollStart;\n                startEdge.onPull(Math.abs(over) / width);\n                needsInvalidate = true;\n            }\n            clampedScrollStart = startBound;\n        } else if (scrollStart > endBound) {\n            if (endAbsolute) {\n                final float over = scrollStart - endBound;\n                endEdge.onPull(Math.abs(over) / width);\n                needsInvalidate = true;\n            }\n            clampedScrollStart = endBound;\n        } else {\n            clampedScrollStart = scrollStart;\n        }\n\n        // Translate back to absolute coordinates.\n        final float targetScrollX;\n        if (isLayoutRtl()) {\n            targetScrollX = MAX_SCROLL_X - clampedScrollStart;\n        } else {\n            targetScrollX = clampedScrollStart;\n        }\n\n        // Don't lose the rounded component.\n        mLastMotionX += targetScrollX - (int) targetScrollX;\n\n        scrollTo((int) targetScrollX, getScrollY());\n        pageScrolled((int) targetScrollX);\n\n        return needsInvalidate;\n    }\n\n    /**\n     * @return Info about the page at the current scroll position.\n     *         This can be synthetic for a missing middle page; the 'object' field can be null.\n     */\n    private ItemInfo infoForFirstVisiblePage() {\n        final int startOffset = getScrollStart();\n        final int width = getPaddedWidth();\n        final float scrollOffset = width > 0 ? (float) startOffset / width : 0;\n        final float marginOffset = width > 0 ? (float) mPageMargin / width : 0;\n\n        int lastPos = -1;\n        float lastOffset = 0.f;\n        float lastWidth = 0.f;\n        boolean first = true;\n        ItemInfo lastItem = null;\n\n        final int N = mItems.size();\n        for (int i = 0; i < N; i++) {\n            ItemInfo ii = mItems.get(i);\n\n            // Seek to position.\n            if (!first && ii.position != lastPos + 1) {\n                // Create a synthetic item for a missing page.\n                ii = mTempItem;\n                ii.offset = lastOffset + lastWidth + marginOffset;\n                ii.position = lastPos + 1;\n                ii.widthFactor = mAdapter.getPageWidth(ii.position);\n                i--;\n            }\n\n            final float offset = ii.offset;\n            final float startBound = offset;\n            if (first || scrollOffset >= startBound) {\n                final float endBound = offset + ii.widthFactor + marginOffset;\n                if (scrollOffset < endBound || i == mItems.size() - 1) {\n                    return ii;\n                }\n            } else {\n                return lastItem;\n            }\n\n            first = false;\n            lastPos = ii.position;\n            lastOffset = offset;\n            lastWidth = ii.widthFactor;\n            lastItem = ii;\n        }\n\n        return lastItem;\n    }\n\n    private int getScrollStart() {\n        if (isLayoutRtl()) {\n            return MAX_SCROLL_X - getScrollX();\n        } else {\n            return getScrollX();\n        }\n    }\n\n    /**\n     * @param currentPage the position of the page with the first visible starting edge\n     * @param pageOffset the fraction of the right-hand page that's visible\n     * @param velocity the velocity of the touch event stream\n     * @param deltaX the distance of the touch event stream\n     * @return the position of the target page\n     */\n    private int determineTargetPage(int currentPage, float pageOffset, int velocity, int deltaX) {\n        int targetPage;\n        if (Math.abs(deltaX) > mFlingDistance && Math.abs(velocity) > mMinimumVelocity) {\n            targetPage = currentPage - (velocity < 0 ? mLeftIncr : 0);\n        } else {\n            final float truncator = currentPage >= mCurItem ? 0.4f : 0.6f;\n            targetPage = (int) (currentPage - mLeftIncr * (pageOffset + truncator));\n        }\n\n        if (mItems.size() > 0) {\n            final ItemInfo firstItem = mItems.get(0);\n            final ItemInfo lastItem = mItems.get(mItems.size() - 1);\n\n            // Only let the user target pages we have items for\n            targetPage = MathUtils.constrain(targetPage, firstItem.position, lastItem.position);\n        }\n\n        return targetPage;\n    }\n\n    @Override\n    public void draw(Canvas canvas) {\n        super.draw(canvas);\n        boolean needsInvalidate = false;\n\n        final int overScrollMode = getOverScrollMode();\n        if (overScrollMode == View.OVER_SCROLL_ALWAYS ||\n                (overScrollMode == View.OVER_SCROLL_IF_CONTENT_SCROLLS &&\n                        mAdapter != null && mAdapter.getCount() > 1)) {\n            if (!mLeftEdge.isFinished()) {\n                final int restoreCount = canvas.save();\n                final int height = getHeight() - getPaddingTop() - getPaddingBottom();\n                final int width = getWidth();\n\n                canvas.rotate(270);\n                canvas.translate(-height + getPaddingTop(), mFirstOffset * width);\n                mLeftEdge.setSize(height, width);\n                needsInvalidate |= mLeftEdge.draw(canvas);\n                canvas.restoreToCount(restoreCount);\n            }\n            if (!mRightEdge.isFinished()) {\n                final int restoreCount = canvas.save();\n                final int width = getWidth();\n                final int height = getHeight() - getPaddingTop() - getPaddingBottom();\n\n                canvas.rotate(90);\n                canvas.translate(-getPaddingTop(), -(mLastOffset + 1) * width);\n                mRightEdge.setSize(height, width);\n                needsInvalidate |= mRightEdge.draw(canvas);\n                canvas.restoreToCount(restoreCount);\n            }\n        } else {\n            mLeftEdge.finish();\n            mRightEdge.finish();\n        }\n\n        if (needsInvalidate) {\n            // Keep animating\n            postInvalidateOnAnimation();\n        }\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        // Draw the margin drawable between pages if needed.\n        if (mPageMargin > 0 && mMarginDrawable != null && mItems.size() > 0 && mAdapter != null) {\n            final int scrollX = getScrollX();\n            final int width = getWidth();\n\n            final float marginOffset = (float) mPageMargin / width;\n            int itemIndex = 0;\n            ItemInfo ii = mItems.get(0);\n            float offset = ii.offset;\n\n            final int itemCount = mItems.size();\n            final int firstPos = ii.position;\n            final int lastPos = mItems.get(itemCount - 1).position;\n            for (int pos = firstPos; pos < lastPos; pos++) {\n                while (pos > ii.position && itemIndex < itemCount) {\n                    ii = mItems.get(++itemIndex);\n                }\n\n                final float itemOffset;\n                final float widthFactor;\n                if (pos == ii.position) {\n                    itemOffset = ii.offset;\n                    widthFactor = ii.widthFactor;\n                } else {\n                    itemOffset = offset;\n                    widthFactor = mAdapter.getPageWidth(pos);\n                }\n\n                final float left;\n                final float scaledOffset = itemOffset * width;\n                if (isLayoutRtl()) {\n                    left = MAX_SCROLL_X - scaledOffset;\n                } else {\n                    left = scaledOffset + widthFactor * width;\n                }\n\n                offset = itemOffset + widthFactor + marginOffset;\n\n                if (left + mPageMargin > scrollX) {\n                    mMarginDrawable.setBounds((int) left, mTopPageBounds,\n                            (int) (left + mPageMargin + 0.5f), mBottomPageBounds);\n                    mMarginDrawable.draw(canvas);\n                }\n\n                if (left > scrollX + width) {\n                    break; // No more visible, no sense in continuing\n                }\n            }\n        }\n    }\n\n    private void onSecondaryPointerUp(MotionEvent ev) {\n        final int pointerIndex = ev.getActionIndex();\n        final int pointerId = ev.getPointerId(pointerIndex);\n        if (pointerId == mActivePointerId) {\n            // This was our active pointer going up. Choose a new\n            // active pointer and adjust accordingly.\n            final int newPointerIndex = pointerIndex == 0 ? 1 : 0;\n            mLastMotionX = ev.getX(newPointerIndex);\n            mActivePointerId = ev.getPointerId(newPointerIndex);\n            if (mVelocityTracker != null) {\n                mVelocityTracker.clear();\n            }\n        }\n    }\n\n    private void endDrag() {\n        mIsBeingDragged = false;\n        mIsUnableToDrag = false;\n\n        if (mVelocityTracker != null) {\n            mVelocityTracker.recycle();\n            mVelocityTracker = null;\n        }\n    }\n\n    private void setScrollingCacheEnabled(boolean enabled) {\n        if (mScrollingCacheEnabled != enabled) {\n            mScrollingCacheEnabled = enabled;\n            if (USE_CACHE) {\n                final int size = getChildCount();\n                for (int i = 0; i < size; ++i) {\n                    final View child = getChildAt(i);\n                    if (child.getVisibility() != GONE) {\n                        child.setDrawingCacheEnabled(enabled);\n                    }\n                }\n            }\n        }\n    }\n\n    public boolean canScrollHorizontally(int direction) {\n        if (mAdapter == null) {\n            return false;\n        }\n\n        final int width = getPaddedWidth();\n        final int scrollX = getScrollX();\n        if (direction < 0) {\n            return (scrollX > (int) (width * mFirstOffset));\n        } else if (direction > 0) {\n            return (scrollX < (int) (width * mLastOffset));\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Tests scrollability within child views of v given a delta of dx.\n     *\n     * @param v View to test for horizontal scrollability\n     * @param checkV Whether the view v passed should itself be checked for scrollability (true),\n     *               or just its children (false).\n     * @param dx Delta scrolled in pixels\n     * @param x X coordinate of the active touch point\n     * @param y Y coordinate of the active touch point\n     * @return true if child views of v can be scrolled by delta of dx.\n     */\n    protected boolean canScroll(View v, boolean checkV, int dx, int x, int y) {\n        if (v instanceof ViewGroup) {\n            final ViewGroup group = (ViewGroup) v;\n            final int scrollX = v.getScrollX();\n            final int scrollY = v.getScrollY();\n            final int count = group.getChildCount();\n            // Count backwards - let topmost views consume scroll distance first.\n            for (int i = count - 1; i >= 0; i--) {\n                // TODO: Add support for transformed views.\n                final View child = group.getChildAt(i);\n                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight()\n                        && y + scrollY >= child.getTop() && y + scrollY < child.getBottom()\n                        && canScroll(child, true, dx, x + scrollX - child.getLeft(),\n                                y + scrollY - child.getTop())) {\n                    return true;\n                }\n            }\n        }\n\n        return checkV && v.canScrollHorizontally(-dx);\n    }\n\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // Let the focused view and/or our descendants get the key first\n        return super.dispatchKeyEvent(event) || executeKeyEvent(event);\n    }\n\n    /**\n     * You can call this function yourself to have the scroll view perform\n     * scrolling from a key event, just as if the event had been dispatched to\n     * it by the view hierarchy.\n     *\n     * @param event The key event to execute.\n     * @return Return true if the event was handled, else false.\n     */\n    public boolean executeKeyEvent(KeyEvent event) {\n        boolean handled = false;\n        if (event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    handled = arrowScroll(FOCUS_LEFT);\n                    break;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    handled = arrowScroll(FOCUS_RIGHT);\n                    break;\n                case KeyEvent.KEYCODE_TAB:\n                    if (event.hasNoModifiers()) {\n                        handled = arrowScroll(FOCUS_FORWARD);\n                    } else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {\n                        handled = arrowScroll(FOCUS_BACKWARD);\n                    }\n                    break;\n            }\n        }\n        return handled;\n    }\n\n    public boolean arrowScroll(int direction) {\n        View currentFocused = findFocus();\n        if (currentFocused == this) {\n            currentFocused = null;\n        } else if (currentFocused != null) {\n            boolean isChild = false;\n            for (ViewParent parent = currentFocused.getParent(); parent instanceof ViewGroup;\n                    parent = parent.getParent()) {\n                if (parent == this) {\n                    isChild = true;\n                    break;\n                }\n            }\n            if (!isChild) {\n                // This would cause the focus search down below to fail in fun ways.\n                final StringBuilder sb = new StringBuilder();\n                sb.append(currentFocused.getClass().getSimpleName());\n                for (ViewParent parent = currentFocused.getParent(); parent instanceof ViewGroup;\n                        parent = parent.getParent()) {\n                    sb.append(\" => \").append(parent.getClass().getSimpleName());\n                }\n                Log.e(TAG, \"arrowScroll tried to find focus based on non-child \" +\n                        \"current focused view \" + sb.toString());\n                currentFocused = null;\n            }\n        }\n\n        boolean handled = false;\n\n        View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused,\n                direction);\n        if (nextFocused != null && nextFocused != currentFocused) {\n            if (direction == View.FOCUS_LEFT) {\n                // If there is nothing to the left, or this is causing us to\n                // jump to the right, then what we really want to do is page left.\n                final int nextLeft = getChildRectInPagerCoordinates(mTempRect, nextFocused).left;\n                final int currLeft = getChildRectInPagerCoordinates(mTempRect, currentFocused).left;\n                if (currentFocused != null && nextLeft >= currLeft) {\n                    handled = pageLeft();\n                } else {\n                    handled = nextFocused.requestFocus();\n                }\n            } else if (direction == View.FOCUS_RIGHT) {\n                // If there is nothing to the right, or this is causing us to\n                // jump to the left, then what we really want to do is page right.\n                final int nextLeft = getChildRectInPagerCoordinates(mTempRect, nextFocused).left;\n                final int currLeft = getChildRectInPagerCoordinates(mTempRect, currentFocused).left;\n                if (currentFocused != null && nextLeft <= currLeft) {\n                    handled = pageRight();\n                } else {\n                    handled = nextFocused.requestFocus();\n                }\n            }\n        } else if (direction == FOCUS_LEFT || direction == FOCUS_BACKWARD) {\n            // Trying to move left and nothing there; try to page.\n            handled = pageLeft();\n        } else if (direction == FOCUS_RIGHT || direction == FOCUS_FORWARD) {\n            // Trying to move right and nothing there; try to page.\n            handled = pageRight();\n        }\n        if (handled) {\n            playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));\n        }\n        return handled;\n    }\n\n    private Rect getChildRectInPagerCoordinates(Rect outRect, View child) {\n        if (outRect == null) {\n            outRect = new Rect();\n        }\n        if (child == null) {\n            outRect.set(0, 0, 0, 0);\n            return outRect;\n        }\n        outRect.left = child.getLeft();\n        outRect.right = child.getRight();\n        outRect.top = child.getTop();\n        outRect.bottom = child.getBottom();\n\n        ViewParent parent = child.getParent();\n        while (parent instanceof ViewGroup && parent != this) {\n            final ViewGroup group = (ViewGroup) parent;\n            outRect.left += group.getLeft();\n            outRect.right += group.getRight();\n            outRect.top += group.getTop();\n            outRect.bottom += group.getBottom();\n\n            parent = group.getParent();\n        }\n        return outRect;\n    }\n\n    boolean pageLeft() {\n        return setCurrentItemInternal(mCurItem + mLeftIncr, true, false);\n    }\n\n    boolean pageRight() {\n        return setCurrentItemInternal(mCurItem - mLeftIncr, true, false);\n    }\n\n    @Override\n    public void onRtlPropertiesChanged(@ResolvedLayoutDir int layoutDirection) {\n        super.onRtlPropertiesChanged(layoutDirection);\n\n        if (layoutDirection == LAYOUT_DIRECTION_LTR) {\n            mLeftIncr = -1;\n        } else {\n            mLeftIncr = 1;\n        }\n    }\n\n    /**\n     * We only want the current page that is being shown to be focusable.\n     */\n    @Override\n    public void addFocusables(ArrayList<View> views, int direction, int focusableMode) {\n        final int focusableCount = views.size();\n\n        final int descendantFocusability = getDescendantFocusability();\n\n        if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {\n            for (int i = 0; i < getChildCount(); i++) {\n                final View child = getChildAt(i);\n                if (child.getVisibility() == VISIBLE) {\n                    ItemInfo ii = infoForChild(child);\n                    if (ii != null && ii.position == mCurItem) {\n                        child.addFocusables(views, direction, focusableMode);\n                    }\n                }\n            }\n        }\n\n        // we add ourselves (if focusable) in all cases except for when we are\n        // FOCUS_AFTER_DESCENDANTS and there are some descendants focusable.  this is\n        // to avoid the focus search finding layouts when a more precise search\n        // among the focusable children would be more interesting.\n        if (\n            descendantFocusability != FOCUS_AFTER_DESCENDANTS ||\n                // No focusable descendants\n                (focusableCount == views.size())) {\n            // Note that we can't call the superclass here, because it will\n            // add all views in.  So we need to do the same thing View does.\n            if (!isFocusable()) {\n                return;\n            }\n            if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE &&\n                    isInTouchMode() && !isFocusableInTouchMode()) {\n                return;\n            }\n            if (views != null) {\n                views.add(this);\n            }\n        }\n    }\n\n    /**\n     * We only want the current page that is being shown to be touchable.\n     */\n    @Override\n    public void addTouchables(ArrayList<View> views) {\n        // Note that we don't call super.addTouchables(), which means that\n        // we don't call View.addTouchables().  This is okay because a ViewPager\n        // is itself not touchable.\n        for (int i = 0; i < getChildCount(); i++) {\n            final View child = getChildAt(i);\n            if (child.getVisibility() == VISIBLE) {\n                ItemInfo ii = infoForChild(child);\n                if (ii != null && ii.position == mCurItem) {\n                    child.addTouchables(views);\n                }\n            }\n        }\n    }\n\n    /**\n     * We only want the current page that is being shown to be focusable.\n     */\n    @Override\n    protected boolean onRequestFocusInDescendants(int direction,\n            Rect previouslyFocusedRect) {\n        int index;\n        int increment;\n        int end;\n        int count = getChildCount();\n        if ((direction & FOCUS_FORWARD) != 0) {\n            index = 0;\n            increment = 1;\n            end = count;\n        } else {\n            index = count - 1;\n            increment = -1;\n            end = -1;\n        }\n        for (int i = index; i != end; i += increment) {\n            View child = getChildAt(i);\n            if (child.getVisibility() == VISIBLE) {\n                ItemInfo ii = infoForChild(child);\n                if (ii != null && ii.position == mCurItem) {\n                    if (child.requestFocus(direction, previouslyFocusedRect)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected ViewGroup.LayoutParams generateDefaultLayoutParams() {\n        return new LayoutParams();\n    }\n\n    @Override\n    protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {\n        return generateDefaultLayoutParams();\n    }\n\n    @Override\n    protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {\n        return p instanceof LayoutParams && super.checkLayoutParams(p);\n    }\n\n    @Override\n    public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {\n        return new LayoutParams(getContext(), attrs);\n    }\n\n\n    @Override\n    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {\n        super.onInitializeAccessibilityEvent(event);\n\n        event.setClassName(ViewPager.class.getName());\n        event.setScrollable(canScroll());\n\n        if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SCROLLED && mAdapter != null) {\n            event.setItemCount(mAdapter.getCount());\n            event.setFromIndex(mCurItem);\n            event.setToIndex(mCurItem);\n        }\n    }\n\n    @Override\n    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {\n        super.onInitializeAccessibilityNodeInfo(info);\n\n        info.setClassName(ViewPager.class.getName());\n        info.setScrollable(canScroll());\n\n        if (canScrollHorizontally(1)) {\n            info.addAction(AccessibilityAction.ACTION_SCROLL_FORWARD);\n            info.addAction(AccessibilityAction.ACTION_SCROLL_RIGHT);\n        }\n\n        if (canScrollHorizontally(-1)) {\n            info.addAction(AccessibilityAction.ACTION_SCROLL_BACKWARD);\n            info.addAction(AccessibilityAction.ACTION_SCROLL_LEFT);\n        }\n    }\n\n    @Override\n    public boolean performAccessibilityAction(int action, Bundle args) {\n        if (super.performAccessibilityAction(action, args)) {\n            return true;\n        }\n\n        switch (action) {\n            case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:\n            case R.id.accessibilityActionScrollRight:\n                if (canScrollHorizontally(1)) {\n                    setCurrentItem(mCurItem + 1);\n                    return true;\n                }\n                return false;\n            case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:\n            case R.id.accessibilityActionScrollLeft:\n                if (canScrollHorizontally(-1)) {\n                    setCurrentItem(mCurItem - 1);\n                    return true;\n                }\n                return false;\n        }\n\n        return false;\n    }\n\n    private boolean canScroll() {\n        return mAdapter != null && mAdapter.getCount() > 1;\n    }\n\n    private class PagerObserver extends DataSetObserver {\n        @Override\n        public void onChanged() {\n            dataSetChanged();\n        }\n        @Override\n        public void onInvalidated() {\n            dataSetChanged();\n        }\n    }\n\n    /**\n     * Layout parameters that should be supplied for views added to a\n     * ViewPager.\n     */\n    public static class LayoutParams extends ViewGroup.LayoutParams {\n        /**\n         * true if this view is a decoration on the pager itself and not\n         * a view supplied by the adapter.\n         */\n        public boolean isDecor;\n\n        /**\n         * Gravity setting for use on decor views only:\n         * Where to position the view page within the overall ViewPager\n         * container; constants are defined in {@link android.view.Gravity}.\n         */\n        @InspectableProperty(\n                name = \"layout_gravity\",\n                valueType = InspectableProperty.ValueType.GRAVITY)\n        public int gravity;\n\n        /**\n         * Width as a 0-1 multiplier of the measured pager width\n         */\n        float widthFactor = 0.f;\n\n        /**\n         * true if this view was added during layout and needs to be measured\n         * before being positioned.\n         */\n        boolean needsMeasure;\n\n        /**\n         * Adapter position this view is for if !isDecor\n         */\n        int position;\n\n        /**\n         * Current child index within the ViewPager that this view occupies\n         */\n        int childIndex;\n\n        public LayoutParams() {\n            super(FILL_PARENT, FILL_PARENT);\n        }\n\n        public LayoutParams(Context context, AttributeSet attrs) {\n            super(context, attrs);\n\n            final TypedArray a = context.obtainStyledAttributes(attrs, LAYOUT_ATTRS);\n            gravity = a.getInteger(0, Gravity.TOP);\n            a.recycle();\n        }\n    }\n\n    static class ViewPositionComparator implements Comparator<View> {\n        @Override\n        public int compare(View lhs, View rhs) {\n            final LayoutParams llp = (LayoutParams) lhs.getLayoutParams();\n            final LayoutParams rlp = (LayoutParams) rhs.getLayoutParams();\n            if (llp.isDecor != rlp.isDecor) {\n                return llp.isDecor ? 1 : -1;\n            }\n            return llp.position - rlp.position;\n        }\n    }\n}\n
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+--- com/android/internal/widget/ViewPager.java	(revision cb0a8564dd664fda5d4b0c9e399c54dabccbea85)
++++ com/android/internal/widget/ViewPager.java	(date 1634645373011)
+@@ -667,6 +667,7 @@
+      * @param limit How many pages will be kept offscreen in an idle state.
+      */
+     public void setOffscreenPageLimit(int limit) {
++        //DEFAULT_OFFSCREEN_PAGES为1
+         if (limit < DEFAULT_OFFSCREEN_PAGES) {
+             Log.w(TAG, "Requested offscreen page limit " + limit + " too small; defaulting to " +
+                     DEFAULT_OFFSCREEN_PAGES);
+Index: .idea/vcs.xml
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+--- .idea/vcs.xml	(date 1635424042879)
++++ .idea/vcs.xml	(date 1635424042879)
+@@ -0,0 +1,6 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<project version="4">
++  <component name="VcsDirectoryMappings">
++    <mapping directory="" vcs="Git" />
++  </component>
++</project>
+\ No newline at end of file
+Index: .idea/gradle.xml
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+--- .idea/gradle.xml	(date 1635424076317)
++++ .idea/gradle.xml	(date 1635424076317)
+@@ -0,0 +1,21 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<project version="4">
++  <component name="GradleMigrationSettings" migrationVersion="1" />
++  <component name="GradleSettings">
++    <option name="linkedExternalProjectsSettings">
++      <GradleProjectSettings>
++        <option name="testRunner" value="PLATFORM" />
++        <option name="distributionType" value="DEFAULT_WRAPPED" />
++        <option name="externalProjectPath" value="$PROJECT_DIR$" />
++        <option name="modules">
++          <set>
++            <option value="$PROJECT_DIR$" />
++            <option value="$PROJECT_DIR$/app" />
++          </set>
++        </option>
++        <option name="resolveModulePerSourceSet" value="false" />
++        <option name="useQualifiedModuleNames" value="true" />
++      </GradleProjectSettings>
++    </option>
++  </component>
++</project>
+\ No newline at end of file
+Index: .idea/compiler.xml
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+--- .idea/compiler.xml	(date 1635424076306)
++++ .idea/compiler.xml	(date 1635424076306)
+@@ -0,0 +1,6 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<project version="4">
++  <component name="CompilerConfiguration">
++    <bytecodeTargetLevel target="1.8" />
++  </component>
++</project>
+\ No newline at end of file
Index: .idea/.name
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/.name	(date 1635424076095)
+++ .idea/.name	(date 1635424076095)
@@ -0,0 +1,1 @@
+source-30
\ No newline at end of file
